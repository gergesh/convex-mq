# ConvexMQ

A typed message queue for Convex, enabling external services to consume messages reactively via Convex subscriptions.

**npm package name:** `convex-mq`

## Project structure

```
src/component/          Convex component (deployed by consumer apps, not compiled by us)
  schema.ts             Table schema: messages { payload, status, attempts, maxAttempts, visibilityTimeoutMs, claimId }
  public.ts             Public API: publish, publishBatch, peek, claim, ack, nack
  lib.ts                Internal: reclaimStale (scheduled visibility timeout recovery)
  _generated/           Generated by `bunx convex dev` — do not edit

src/client/             Client library (compiled to dist/)
  index.ts              Component mode: MessageQueue<V> class — typed via Convex validators, api() generates exports
  table.ts              Library mode: messageQueueTable() schema helper + MessageQueue class using ctx.db directly
  client.ts             consume() (reactive) and consumePolling() helpers — shared by both modes

convex/                 Host app for development/testing (uses both modes)
  convex.config.ts      Installs component as emailQueue and taskQueue
  emailQueue.ts         Component mode — emailQueue.api(query, mutation)
  taskQueue.ts          Component mode — taskQueue.api(query, mutation)
  workerTasks.ts        Library mode — unfiltered + filtered by worker
  schema.ts             Includes workerTasks table via messageQueueTable()

test/                   Tests (all vitest)
  messageQueue.test.ts  Unit tests via convex-test (including claimId race condition tests)
  consume.integration.test.ts   Integration tests against live deployment (component mode)
  concurrent.integration.test.ts  Concurrent consumer + queue isolation tests (component mode)
  libraryMode.integration.test.ts  Library mode integration tests (filtered + unfiltered)

examples/               Example consumer scripts
```

## Key commands

- `bun install` — install dependencies
- `bun run build` — compile client code to dist/ (component source is shipped as-is)
- `bunx convex dev --once` — deploy to dev and regenerate types
- `bunx vitest run` — run all tests (unit + integration)

## Architecture decisions

### Shared (both modes)

- **No timestamps** — FIFO ordering uses `_creationTime` (built-in). Visibility timeout uses `ctx.scheduler.runAfter`. No manual `Date.now()` calls.
- **ack deletes** — messages are removed from the table on ack. No "completed" state, no purge needed.
- **nack returns payload when exhausted** — instead of a "failed" state, nack deletes the message and returns it to the caller when retries are exhausted, so they can decide what to do (dead-letter, log, etc.).
- **peek is a boolean signal** — reads exactly one document. Consumers subscribe to it as a wake-up signal, then call claim() to get actual payloads.
- **claimId lease tokens** — each claim() generates a random claimId. ack/nack must provide the matching claimId. If a visibility timeout fires and another consumer reclaims the message, the original consumer's claimId is invalidated, preventing stale ack/nack race conditions.
- **reclaimStale always returns to pending** — the scheduled visibility timeout handler never deletes messages. Only explicit nack can exhaust retries. This prevents silent message loss.
- **api() generates all exports** — eliminates ~50 lines of boilerplate per queue. `V` is constrained to `VObject` so publish args are flat (validator fields spread as top-level args).
- **consume() takes the module directly** — `consume(client, api.emailQueue, handler)` instead of spelling out 4 function references. `QueueFunctions<T>` is generic so payload types flow from function refs into the handler.
- **consume() options** — filter args and consumer options (batchSize, pollIntervalMs) are merged into a single options object. Known keys are extracted; the rest are forwarded to peek/claim as filter args.

### Component mode

- **Component source is not compiled** — `tsconfig.build.json` only includes `src/client/`. Convex processes the component source at deploy time. The `_generated/` directory is created by `bunx convex dev`.
- **One message type per queue instance** — multiple types = multiple `app.use(messageQueue, { name: "x" })` in the host's `convex.config.ts`. Each instance gets an isolated table.
- **Payload nested in `v.object()`** — the `message` config wraps a validator object. Claimed messages expose `payload`.

### Library mode

- **User owns the table** — defined in the app's own schema via `messageQueueTable(fields)`, enabling custom indexes and filtered consumption.
- **User fields are top-level** — not nested under `payload`, so they're directly indexable. Claimed messages expose `data` (not `payload`).
- **System fields** — `status`, `attempts`, `maxAttempts`, `visibilityTimeoutMs`, `claimId` — reserved names added by `messageQueueTable()`.
- **`messageQueueTable()` adds `by_status` index** — the default index for unfiltered consumption. Custom indexes should prefix with `"status"` for filtered peek/claim.
- **`modulePath` defaults to table name** — used for `makeFunctionReference` to schedule `reclaimStale` via `ctx.scheduler.runAfter`. Convention: file name matches table name (e.g., `convex/tasks.ts` for table `"tasks"`). Override via options if different.
- **Filtered consumption** — `api()` accepts `filterConfig` with `filterArgs` (validators) and `filter` (function that applies index conditions). Multiple `api()` calls on the same queue instance can generate different filtered views.
- **No component dependency** — library mode uses `ctx.db` directly, no component installation needed.

## Testing

Tests use **vitest** (not bun:test) because `convex-test` depends on `import.meta.glob` which is a Vite feature. Integration tests hit the live Convex deployment configured in `.env.local`. Test files must run sequentially (`fileParallelism: false` in vitest config) because integration tests share the live deployment's state.

## Working with the component

- The component's public functions (in `src/component/public.ts`) use `v.any()` for payloads — typing is enforced at the client wrapper level via `MessageQueue<V>`.
- Host apps use `emailQueue.api(query, mutation)` to generate all queue function exports. Custom publish wrappers are unnecessary since `api()` generates a `publish` that accepts flat payload args.
- The `consume()` helper manages a reactive subscription loop with a drain pattern: it keeps claiming until the queue is empty, and re-enters if new messages arrive during processing.

## Working with library mode

- `messageQueueTable(fields)` returns a table definition — chain `.index()` for custom indexes.
- `MessageQueue(tableName, fields, options?)` — fields must match what was passed to `messageQueueTable()`.
- `api()` can be called multiple times with different `filterConfig` to generate multiple filtered views (e.g., `peekByWorker`, `claimByWorker`).
- The `reclaimStale` export is required — it's the visibility timeout handler called by the scheduler. Must be exported from the module at `modulePath`.
